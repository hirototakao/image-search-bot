"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareFunctionArgs = exports.createFunctionFail = exports.createFunctionComplete = exports.isFunctionEvent = exports.processStepMiddleware = exports.validate = exports.WorkflowFunction = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const web_api_1 = require("@slack/web-api");
const process_1 = __importDefault(require("./middleware/process"));
const errors_1 = require("./errors");
/** Constants */
const VALID_PAYLOAD_TYPES = new Set(['function_executed']);
/** Class */
class WorkflowFunction {
    constructor(callbackId, middleware) {
        validate(callbackId, middleware);
        this.callbackId = callbackId;
        this.middleware = middleware;
    }
    getMiddleware() {
        return async (args) => {
            if (isFunctionEvent(args) && this.matchesConstraints(args)) {
                return this.processEvent(args);
            }
            return args.next();
        };
    }
    matchesConstraints(args) {
        return args.payload.function.callback_id === this.callbackId;
    }
    async processEvent(args) {
        const functionArgs = prepareFunctionArgs(args);
        const stepMiddleware = this.getStepMiddleware();
        return processStepMiddleware(functionArgs, stepMiddleware);
    }
    getStepMiddleware() {
        return this.middleware;
    }
}
exports.WorkflowFunction = WorkflowFunction;
/** Helper Functions */
function validate(callbackId, listeners) {
    // Ensure callbackId is valid
    if (typeof callbackId !== 'string') {
        const errorMsg = 'WorkflowFunction expects a callback_id as the first argument';
        throw new errors_1.WorkflowFunctionInitializationError(errorMsg);
    }
    // Ensure all listeners are functions
    listeners.forEach((listener) => {
        if (!(listener instanceof Function)) {
            const errorMsg = 'All WorkflowFunction listeners must be functions';
            throw new errors_1.WorkflowFunctionInitializationError(errorMsg);
        }
    });
}
exports.validate = validate;
/**
 * `processStepMiddleware()` invokes each callback for lifecycle event
 * @param args workflow_step_edit action
 */
async function processStepMiddleware(args, middleware) {
    const { context, client, logger } = args;
    const callbacks = [...middleware];
    const lastCallback = callbacks.pop();
    if (lastCallback !== undefined) {
        await (0, process_1.default)(callbacks, args, context, client, logger, async () => lastCallback({ ...args, context, client, logger }));
    }
}
exports.processStepMiddleware = processStepMiddleware;
function isFunctionEvent(args) {
    return VALID_PAYLOAD_TYPES.has(args.payload.type);
}
exports.isFunctionEvent = isFunctionEvent;
function selectToken(context) {
    // If attachFunctionToken = false, fallback to botToken or userToken
    return context.functionBotToken ? context.functionBotToken : context.botToken || context.userToken;
}
/**
 * Factory for `complete()` utility
 * @param args function_executed event
 */
function createFunctionComplete(args) {
    const { context, client, payload: { function_execution_id }, } = args;
    const token = selectToken(context);
    return (params = {}) => client.functions.completeSuccess({
        token,
        outputs: params.outputs || {},
        function_execution_id,
    });
}
exports.createFunctionComplete = createFunctionComplete;
/**
 * Factory for `fail()` utility
 * @param args function_executed event
 */
function createFunctionFail(args) {
    const { context, client, payload: { function_execution_id }, } = args;
    const token = selectToken(context);
    return (params) => {
        const { error } = params !== null && params !== void 0 ? params : {};
        return client.functions.completeError({
            token,
            error,
            function_execution_id,
        });
    };
}
exports.createFunctionFail = createFunctionFail;
/**
 * `prepareFunctionArgs()` takes in a function's args and:
 *  1. removes the next() passed in from App-level middleware processing
 *    - events will *not* continue down global middleware chain to subsequent listeners
 *  2. augments args with step lifecycle-specific properties/utilities
 * */
function prepareFunctionArgs(args) {
    const { next: _next, ...functionArgs } = args;
    const preparedArgs = { ...functionArgs };
    const token = selectToken(functionArgs.context);
    // Making calls with a functionBotToken establishes continuity between
    // a function_executed event and subsequent interactive events (actions)
    const client = new web_api_1.WebClient(token, { ...functionArgs.client });
    preparedArgs.client = client;
    // Utility args
    preparedArgs.inputs = preparedArgs.event.inputs;
    preparedArgs.complete = createFunctionComplete(preparedArgs);
    preparedArgs.fail = createFunctionFail(preparedArgs);
    return preparedArgs;
}
exports.prepareFunctionArgs = prepareFunctionArgs;
//# sourceMappingURL=WorkflowFunction.js.map